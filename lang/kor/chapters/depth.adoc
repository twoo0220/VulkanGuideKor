// Copyright 2019-2022 The Khronos Group, Inc.
// SPDX-License-Identifier: CC-BY-4.0

// Required for both single-page and combined guide xrefs to work
ifndef::chapters[:chapters:]
ifndef::images[:images: images/]

[[Depth]]
= 깊이(Depth)

xref:{chapters}vulkan_spec.adoc[Vulkan Spec] 의 다양한 부분에서 `depth` 라는 용어가 사용되고 있습니다. 이 장은 Vulkan 에서 사용되는 다양한 "깊이(depth)" 용어에 대한 개요를 제공하는 것을 목표로 합니다. 이 장을 최대한 활용하려면 3D 그래픽스에 대한 기본적인 지식이 필요합니다.

[NOTE]
====
스텐실은 깊이와 밀접한 관련이 있지만, 이 장에서는 API 이름 영역 밖의 내용을 다루지 않습니다.
====

  *  <<graphics-pipeline, 그래픽스 파이프라인(Graphics Pipeline)>>
  *  <<depth-formats, 깊이 포맷(Depth Formats)>>
  *  <<depth-buffer-as-a-vkimage, VkImage의 깊이 버퍼(Depth Buffer)>>
  **  <<layout, 레이아웃(Layout)>>
  **  <<clearing, 정리(Clearing)>>
  *  <<pre-rasterization, 래스터화 전(Pre-rasterization)>>
  **  <<primitive-clipping, 프리미티브 클리핑(Primitive Clipping)>>
  ***  <<user-defined-clipping-and-culling, 사용자 정의 클리핑 및 컬링>>
  ***  <<porting-from-opengl, OpenGL로부터 포팅>>
  **  <<viewport-transformation, 뷰포트 변환(Viewport Transformation)>>
  ***  <<depth-range, 깊이 범위(Depth Range)>>
  *  <<rasterization, 래스터화(Rasterization)>>
  **  <<depth-bias, 깊이 바이어스(Depth Bias)>>
  *  <<post-rasterization, 래스터화 후(Post-rasterization)>>
  **  <<fragment-shader, 프래그먼트 쉐이더(Fragment Shader)>>
  ***  <<conservative-depth, 보수적인 깊이(Conservative depth)>>
  **  <<per-sample-processing-and-coverage-mask, 샘플별 처리 및 커버리지 마스크(Per-sample processing and coverage mask)>>
  ***  <<resolving-depth-buffer, 깊이 버퍼 처리(Resolving depth buffer)>>
  **  <<depth-bounds, 깊이 제한(Depth Bounds)>>
  **  <<depth-test, 깊이 테스트(Depth Test)>>
  ***  <<depth-compare-operation, 깊이 비교 연산(Depth Compare Operation)>>
  ***  <<depth-buffer-writes, 깊이 버퍼 쓰기(Depth Buffer Writes)>>
  ***  <<depth-clamping, 깊이 클램핑(Depth Clamping)>>

[[graphics-pipeline]]
== 그래픽스 파이프라인(Graphics Pipeline)

"깊이(depth)" 개념은 xref:{chapters}what_vulkan_can_do.adoc[graphics pipelines] 에만 사용되며 드로우콜이 제출될 때까지 적용되지 않습니다.

`VkGraphicsPipelineCreateInfo` 내부에는 `depth` 와 관련된 다양한 제어 가능한 값들이 있습니다. 일부 상태는 xref:{chapters}dynamic_state.adoc[dynamic] 이기도 합니다.

[[depth-formats]]
== 깊이 포맷(Depth Formats)

몇 가지 깊이 형식이 있으며, 구현에 따라 Vulkan에서 지원되는 형식이 노출될 수 있습니다.

깊이 이미지에서 **읽기(reading)**에 필요한 포맷은 샘플링이나 블릿 연산을 통한 읽기를 지원하기 위한 `VK_FORMAT_D16_UNORM` 과 `VK_FORMAT_D32_SFLOAT` 뿐입니다.

깊이 이미지에서 **쓰기(writing)**를 하려면 `VK_FORMAT_D16_UNORM` 이 지원되어야 합니다. 여기에서 (`VK_FORMAT_X8_D24_UNORM_PACK32` **또는** `VK_FORMAT_D32_SFLOAT`) ** 및 ** (`VK_FORMAT_D24_UNORM_S8_UINT` **또는** `VK_FORMAT_D32_SFLOAT_S8_UINT`) 중 적어도 하나를 지원해야 합니다. 따라서 깊이와 스텐실이 **모두** 같은 포맷으로 필요한 경우 사용할 포맷을 착이 위해 여분의 로직이 필요합니다.

[source,cpp]
----
// 쿼리 로직 예시
VkFormatProperties properties;

vkGetPhysicalDeviceFormatProperties(physicalDevice, VK_FORMAT_D24_UNORM_S8_UINT, &properties);
bool d24s8_support = (properties.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT);

vkGetPhysicalDeviceFormatProperties(physicalDevice, VK_FORMAT_D32_SFLOAT_S8_UINT, &properties);
bool d32s8_support = (properties.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT);

assert(d24s8_support | d32s8_support); // 적어도 하나를 항상 지원
----

[[depth-buffer-as-a-vkimage]]
== 깊이 버퍼를 VkImage로 사용

"깊이 버퍼" 라는 용어는 그래픽스에 대해 이야기할 때 많이 사용되지만, Vulkan에서는 `VkFramebuffer` 가 그리기 시점에 참조할 수 있는 `VkImage`/`VkImageView` 에 불과합니다. `VkRenderPass` 를 생성할 때 `pDepthStencilAttachment` 값은 프레임버퍼의 깊이 첨부(attachment)를 가리킵니다.(attachment : (주로 이미지) 버퍼 데이터를 원하는 용도로 장치가 사용할 수 있게 제공)

`pDepthStencilAttachment` 를 사용하려면 `VkImage` 는 `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` 로 작성되어 있어야 합니다.

이미지 장벽이나 정리(Clearing) 등 `VkImageAspectFlags` 가 필요한 작업을 수행할 때, `VK_IMAGE_ASPECT_DEPTH_BIT` 는 깊이 메모리를 참조하는 데 사용됩니다.

[[layout]]
=== 레이아웃(Layout)

`VkImageLayout` 를 선택할 때 이미지에 대한 읽기 및 쓰기를 **모두** 허용하는 레이아웃이 있습니다:

  * VK_IMAGE_LAYOUT_**DEPTH**\_STENCIL_**ATTACHMENT**_OPTIMAL
  * VK_IMAGE_LAYOUT_**DEPTH_ATTACHMENT**_STENCIL_READ_ONLY_OPTIMAL
  * VK_IMAGE_LAYOUT_**DEPTH_ATTACHMENT**_OPTIMAL

뿐만 아니라 이미지를 읽을 수 **만** 있는 레이아웃도 지원합니다:

  * VK_IMAGE_LAYOUT_**DEPTH**\_STENCIL_**READ_ONLY**_OPTIMAL
  * VK_IMAGE_LAYOUT_**DEPTH_READ_ONLY**_STENCIL_ATTACHMENT_OPTIMAL
  * VK_IMAGE_LAYOUT_**DEPTH_READ_ONLY**_OPTIMAL

레이아웃 전환을 수행할 때 깊이 이미지 읽기 및 쓰기에 필요한 적절한 깊이 액세스 마스크를 설정해야 합니다.

[source,cpp]
----
// 정의되지 않은 레이아웃에서 읽고 쓸 수 있는 깊이 첨부로 변경하는 예시

// 핵심 Vulkan 예시
srcAccessMask = 0;
dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
destinationStage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;

// VK_KHR_synchronization2
srcAccessMask = VK_ACCESS_2_NONE_KHR;
dstAccessMask = VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR | VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR;
sourceStage = VK_PIPELINE_STAGE_2_NONE_KHR;
destinationStage = VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR | VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR;
----

[NOTE]
====
애플리케이션에 초기 또는 후기 프래그먼트 테스트 중 하나만 사용할지 확실하지 않은 경우 둘 다 사용하세요.
====

[[clearing]]
=== 정리(Clearing)

깊이 버퍼를 지우는 것은 `loadOp` 을 `VK_ATTACHMENT_LOAD_OP_CLEAR` 로 설정하여 패스 시작 시 수행하는 것이 언제나 좋지만, `vkCmdClearDepthStencilImage` 를 사용하여 렌더링 패스 밖에서도 깊이 이미지를 지울 수 있습니다.

정리할 때, `VkClearValue` 는 유니온이며, 색상 지우기 값 대신 `VkClearDepthStencilValue depthStencil` 을 설정할 필요가 있는 것에 주의해 주세요.

[[pre-rasterization]]
== 래스터화 전(Pre-rasterization)

그래픽스 파이프라인에는 래스터화할 프리미티브를 생성하는 일련의  link:https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization[래스터화 전 쉐이더 단계] 가 있습니다. 래스터화 단계에 도달하기 전에 래스터화 전 마지막 단계의 최종 `vec4` 위치(`gl_Position`)는  link:https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#vertexpostproc[고정 함수 정점 포스트 프로세싱] 을 통해 실행됩니다.

다음은 래스터화 전에 수행되는 다양한 좌표명과 연산에 대한 개괄적인 개요입니다.

image::{images}depth_coordinates_flow.png[depth_coordinates_flow]

[[primitive-clipping]]
=== 프리미티브 클리핑(Primitive Clipping)

프리미티브가 `view volume` 외부에 있는 경우, xref:{chapters}extensions/translation_layer_extensions.adoc#vk_ext_depth_clip_enable[VK_EXT_depth_clip_enable]의 `depthClipEnable` 를 사용하지 않는 한 클리핑은 항상 수행됩니다. Vulkan에서는 깊이에 대해 다음과 같이 표현됩니다.

[source]
----
0 <= Zc <= Wc
----

정규화된 장치 좌표(NDC)를 계산할 때, `[0, 1]` 을 벗어나는 것은 모두 잘립니다.

`Zd` 가 `Zc`/`Wc` 의 결과인 몇 가지 예시:

  * `vec4(1.0, 1.0, 2.0, 2.0)` - not clipped (`Zd` == `1.0`)
  * `vec4(1.0, 1.0, 0.0, 2.0)` - not clipped (`Zd` == `0.0`)
  * `vec4(1.0, 1.0, -1.0, 2.0)` - clipped  (`Zd` == `-0.5`)
  * `vec4(1.0, 1.0, -1.0, -2.0)` - not clipped (`Zd` == `0.5`)

[[user-defined-clipping-and-culling]]
==== 사용자 정의 클리핑 및 컬링(User defined clipping and culling)

`ClipDistance` 및 `CullDistance` 내장 배열을 사용하여 link:https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#pipeline-graphics-subsets-pre-rasterization[래스터화 전 쉐이더 단계] 에서 link:https://www.khronos.org/opengl/wiki/Vertex_Post-Processing#User-defined_clipping[사용자 정의 클리핑 및 컬링]을 설정할 수 있습니다.

마지막 래스터화 전 쉐이더 단계에서 이 값은 프리미티브 전체에 걸쳐 선형 보간되며 보간된 거리가 `0` 보다 작은 프리미티브 부분은 클립 볼퓸 외부로 간주됩니다. 이후 프래그먼트 쉐이더에서 `ClipDistance` 또는 `CullDistance` 를 사용하는 경우, 이 선형 보간된 값이 포함됩니다.

[NOTE]
====
`ClipDistance` 와 `CullDistance` 는 GLSL에서는 `gl_ClipDistance[]` 와 `gl_CullDistance[]` 입니다.
====

[[porting-from-opengl]]
==== OpenGL로부터 포팅(Porting from OpenGL)

OpenGL에서는 `view volume` 는 다음과 같이 표현됩니다.

[source]
----
-Wc <= Zc <= Wc
----

`[-1, 1]` 의 바깥쪽에 있는 것은 클립됩니다.

link:https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_depth_clip_control.html[VK_EXT_depth_clip_control] 확장을 추가하여 Vulkan 위에 OpenGL을 효율적으로 레이어링할 수 있습니다. `VkPipeline` 을 생성할 때, `VkPipelineViewportDepthClipControlCreateInfoEXT::negativeOneToOne`을 `VK_TRUE` 로 설정하면 OpenGL `[-1, 1]` 뷰 볼륨을 사용할 수 있습니다.

`VK_EXT_depth_clip_control` 을 사용할 수 없는 경우, link:https://github.com/KhronosGroup/Vulkan-Docs/issues/1054#issuecomment-547202276[현재 회피책] 을 사용하여 래스터화 전 쉐이더에서 변환을 수행합니다.

[source,glsl]
----
// [-1,1] to [0,1]
position.z = (position.z + position.w) * 0.5;
----

[[viewport-transformation]]
=== 뷰포트 변환(Viewport Transformation)

뷰포트 변환은 뷰포트 사각형과 깊이 범위를 기준으로 정규화된 장치 좌표에서 프레임버퍼 좌표로 변환하는 것입니다.

파이프라인에서 사용 중인 뷰포트 `VkPipelineViewportStateCreateInfo::pViewports` 러 표현되며,  `VkPipelineViewportStateCreateInfo::viewportCount` 는 사용 중인 뷰포트의 수를 설정합니다. `VkPhysicalDeviceFeatures::multiViewport` 가 활성화되지 않은 경우 뷰포트는 1개만 있어야 합니다.

[NOTE]
====
뷰포트 값은 `VK_DYNAMIC_STATE_VIEWPORT` 또는 link:https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state.html[VK_EXT_extended_dynamic_state] 의 `VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT` 를 사용하여 xref:{chapters}dynamic_state.adoc[dynamically]로 설정할 수 있습니다.
====

[[depth-range]]
==== 깊이 범위(Depth Range)

각 뷰포트에는 뷰포트의 "깊이 범위"를 설정하는 `VkViewport::minDepth` 및 `VkViewport::maxDepth` 값이 있습니다.

[NOTE]
====
이름과 상관없이 `minDepth` 는 `maxDepth` 작든, 같든, 크든 문제없습니다.
====

`minDepth` 와 `maxDepth` 는 `0.0` 에서 `1.0` 사이로만 설정하도록 제한되어 있습니다. link:https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_depth_range_unrestricted.html[VK_EXT_depth_range_unrestricted] 를 활성화하면 이 제한이 사라집니다.

프레임버퍼 깊이 좌표 `Zf` 는 다음과 같이 표시됩니다:

[source]
----
Zf = Pz * Zd + Oz
----

  * `Zd` = `Zc`/`Wc` (see <<primitive-clipping,Primitive Clipping>>)
  * `Oz` = `minDepth`
  * `Pz` = `maxDepth` - `minDepth`

[[rasterization]]
== 래스터화(Rasterization)

[[depth-bias]]
=== 깊이 바이어스(Depth Bias)

The depth values of all fragments generated by the rasterization of a polygon can be offset by a single value that is computed for that polygon. If `VkPipelineRasterizationStateCreateInfo::depthBiasEnable` is `VK_FALSE` at draw time, no depth bias is applied.

Using the `depthBiasConstantFactor`, `depthBiasClamp`, and `depthBiasSlopeFactor` in `VkPipelineRasterizationStateCreateInfo` the depth bias link:https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-depthbias[can be calculated].

[NOTE]
====
Requires the `VkPhysicalDeviceFeatures::depthBiasClamp` feature to be supported otherwise `VkPipelineRasterizationStateCreateInfo::depthBiasClamp` must be `0.0f`.
====

[NOTE]
====
The depth bias values can be set xref:{chapters}dynamic_state.adoc[dynamically] using `VK_DYNAMIC_STATE_DEPTH_BIAS` or the `VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT` from link:https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state2.html[VK_EXT_extended_dynamic_state2].
====

[[post-rasterization]]
== Post-rasterization

[[fragment-shader]]
=== Fragment Shader

The input built-in `FragCoord` is the framebuffer coordinate. The `Z` component is the interpolated depth value of the primitive. This `Z` component value will be written to `FragDepth` if the shader doesn't write to it. If the shader dynamically writes to `FragDepth`, the `DepthReplacing` Execution Mode must be declared (This is done in tools such as glslang).

[NOTE]
====
`FragDepth` and `FragCoord` are `gl_FragDepth` and `gl_FragCoord` in GLSL.
====

[NOTE]
====
When using `OpTypeImage` in SPIR-V the `Depth` operand is ignored in Vulkan
====

[[conservative-depth]]
==== Conservative depth

The `DepthGreater`, `DepthLess`, and `DepthUnchanged` Execution Mode allow for a possible optimization for implementations that link:https://registry.khronos.org/OpenGL/extensions/ARB/ARB_conservative_depth.txt[relies on an early depth test to be run before the fragment]. This can be easily done in GLSL by declaring `gl_FragDepth` with the proper layout qualifier.

[source,glsl]
----
// assume it may be modified in any way
layout(depth_any) out float gl_FragDepth;

// assume it may be modified such that its value will only increase
layout(depth_greater) out float gl_FragDepth;

// assume it may be modified such that its value will only decrease
layout(depth_less) out float gl_FragDepth;

// assume it will not be modified
layout(depth_unchanged) out float gl_FragDepth;
----

Violating the condition​ yields undefined behavior.

[[per-sample-processing-and-coverage-mask]]
=== Per-sample processing and coverage mask

The following post-rasterization occurs as a "per-sample" operation. This means when doing link:https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#fragops-covg[multisampling] with a color attachment, any "depth buffer" `VkImage` used as well must also have been created with the same `VkSampleCountFlagBits` value.

Each fragment has a link:https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-multisampling-coverage-mask[coverage mask] based on which samples within that fragment are determined to be within the area of the primitive that generated the fragment. If a fragment operation results in all bits of the coverage mask being `0`, the fragment is discarded.

[[resolving-depth-buffer]]
==== Resolving depth buffer

It is possible in Vulkan using the xref:{chapters}extensions/cleanup.adoc#vk_khr_depth_stencil_resolve[VK_KHR_depth_stencil_resolve] extension (promoted to Vulkan core in 1.2) to resolve multisampled depth/stencil attachments in a subpass in a similar manner as for color attachments.

[[depth-bounds]]
=== Depth Bounds

[NOTE]
====
Requires the `VkPhysicalDeviceFeatures::depthBounds` feature to be supported.
====

If `VkPipelineDepthStencilStateCreateInfo::depthBoundsTestEnable` is used to take each `Za` in the depth attachment and check if it is within the range set by `VkPipelineDepthStencilStateCreateInfo::minDepthBounds` and `VkPipelineDepthStencilStateCreateInfo::maxDepthBounds`. If the value is not within the bounds, the link:https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-multisampling-coverage-mask[coverage mask] is set to zero.

[NOTE]
====
The depth bound values can be set xref:{chapters}dynamic_state.adoc[dynamically] using `VK_DYNAMIC_STATE_DEPTH_BOUNDS` or the `VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT` from link:https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state.html[VK_EXT_extended_dynamic_state].
====

[[depth-test]]
=== Depth Test

The depth test compares the framebuffer depth coordinate `Zf` with the depth value `Za` in the depth attachment. If the test fails, the fragment is discarded. If the test passes, the depth attachment will be updated with the fragment's output depth. The `VkPipelineDepthStencilStateCreateInfo::depthTestEnable` is used to enable/disable the test in the pipeline.

The following gives a high level overview of the depth test.

image::{images}depth_test.png[depth_test]

[[depth-compare-operation]]
==== Depth Compare Operation

The `VkPipelineDepthStencilStateCreateInfo::depthCompareOp` provides the comparison function used for the depth test.

An example where `depthCompareOp` == `VK_COMPARE_OP_LESS` (`Zf` < `Za`)

  * `Zf` = 1.0 | `Za` = 2.0 | test passes
  * `Zf` = 1.0 | `Za` = 1.0 | test fails
  * `Zf` = 1.0 | `Za` = 0.0 | test fails

[NOTE]
====
The `depthTestEnable` and `depthCompareOp` value can be set xref:{chapters}dynamic_state.adoc[dynamically] using `VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT` and `VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT` from link:https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state.html[VK_EXT_extended_dynamic_state].
====

[[depth-buffer-writes]]
==== Depth Buffer Writes

Even if the depth test passes, if `VkPipelineDepthStencilStateCreateInfo::depthWriteEnable` is set to `VK_FALSE` it will not write the value out to the depth attachment. The main reason for this is because the depth test itself will set the link:https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#primsrast-multisampling-coverage-mask[coverage mask] which can be used for certain render techniques.

[NOTE]
====
The `depthWriteEnable` value can be set xref:{chapters}dynamic_state.adoc[dynamically] using `VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT` from link:https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state.html[VK_EXT_extended_dynamic_state].
====

[[depth-clamping]]
==== Depth Clamping

[NOTE]
====
Requires the `VkPhysicalDeviceFeatures::depthClamp` feature to be supported.
====

Prior to the depth test, if `VkPipelineRasterizationStateCreateInfo::depthClampEnable` is enabled, before the sample’s `Zf` is compared to `Za`, `Zf` is clamped to `[min(n,f), max(n,f)]`, where `n` and `f` are the `minDepth` and `maxDepth` depth range values of the viewport used by this fragment, respectively.

